# KalixCLI STDIO Communication Protocol Specification

## 1. Overview

This specification defines a JSON-based communication protocol over STDIO for interaction between a frontend application and the kalixcli hydrological modeling engine. The protocol enables the frontend to initiate modeling tasks, monitor progress, retrieve results, and interrupt long-running operations while keeping computational data resident in kalixcli memory. Models include both configuration and input data as a unified structure.

## 2. Design Principles

### 2.1 Core Principles
- **Stateful Session**: kalixcli maintains model state, data, and results in memory throughout the session
- **Single Task Execution**: kalixcli processes one command at a time, executing tasks sequentially
- **Interruptible Operations**: Long-running tasks can be interrupted by the frontend
- **Concurrent Communication**: kalixcli listens for commands while executing tasks
- **JSON Message Format**: All communication uses structured JSON for clarity and extensibility
- **Line-Delimited**: Each message is a complete JSON object on a single line
- **Extensible**: Protocol structure allows for future command and message type additions
- **Error Resilient**: Clear error reporting and recovery mechanisms

### 2.2 Communication Flow
1. Frontend spawns kalixcli process
2. kalixcli generates a unique session_id and sends ready signal with available commands
3. Frontend receives session_id and uses it for all subsequent messages
4. Frontend sends command
5. kalixcli sends busy signal indicating task has started
6. kalixcli executes command, sending progress updates while listening for interrupts
7. kalixcli sends result or error (or stopped if interrupted)
8. kalixcli sends ready signal for next command
9. Session continues until explicit termination

### 2.3 State Management
kalixcli operates in two primary states:
- **ready**: No task is executing, waiting for commands
- **busy**: A task is executing, can receive interrupt commands while sending progress updates

## 3. Message Structure

### 3.1 Base Message Format
All messages follow this structure:

```json
{
  "type": "message_type",
  "timestamp": "2025-09-08T10:30:00Z",
  "session_id": "unique_session_identifier",
  "data": {}
}
```

**Note**: The `session_id` is generated by kalixcli when it starts and communicated to the frontend in the initial `ready` message. The frontend must use this session_id in all subsequent messages.

### 3.2 Message Types

#### 3.2.1 System Messages (kalixcli → frontend)
- `ready`: kalixcli is ready for commands
- `busy`: kalixcli has started executing a command
- `progress`: Task progress update
- `result`: Task completion with results
- `stopped`: Task was interrupted and stopped cleanly
- `error`: Error occurred during task execution
- `log`: Informational logging message

#### 3.2.2 Command Messages (frontend → kalixcli)
- `command`: Execute a specific kalixcli command
- `stop`: Interrupt the currently executing task
- `query`: Request information about current state
- `terminate`: End the session gracefully

## 4. Detailed Message Specifications

### 4.1 Ready Message (kalixcli → frontend)
Sent when kalixcli starts (with newly generated session_id) and after each command completion/interruption.

```json
{
  "type": "ready",
  "timestamp": "2025-09-08T10:30:00Z",
  "session_id": "sess_20250908_103000_a7b9",
  "data": {
    "status": "ready",
    "available_commands": [
      {
        "name": "load_model",
        "description": "Load a hydrological model",
        "parameters": [
          {"name": "model_path", "type": "string", "required": true},
          {"name": "validation", "type": "boolean", "required": false, "default": true}
        ]
      },
      {
        "name": "run_simulation",
        "description": "Execute model simulation",
        "parameters": [
          {"name": "start_date", "type": "string", "required": true},
          {"name": "end_date", "type": "string", "required": true},
          {"name": "timestep", "type": "string", "required": false, "default": "daily"}
        ]
      }
    ],
    "current_state": {
      "model_loaded": false,
      "data_loaded": false,
      "last_simulation": null
    }
  }
}
```

### 4.2 Busy Message (kalixcli → frontend)
Sent immediately after kalixcli starts executing a command.

```json
{
  "type": "busy",
  "timestamp": "2025-09-08T10:31:05Z",
  "session_id": "sess_20250908_103000_a7b9",
  "data": {
    "status": "busy",
    "executing_command": "run_simulation",
    "interruptible": true,
    "started_at": "2025-09-08T10:31:05Z"
  }
}
```

### 4.3 Command Message (frontend → kalixcli)
Requests execution of a specific command. Only accepted when kalixcli is in "ready" state.
The frontend must use the session_id received from kalixcli's initial ready message.

```json
{
  "type": "command",
  "timestamp": "2025-09-08T10:31:00Z",
  "session_id": "sess_20250908_103000_a7b9",
  "data": {
    "command": "load_model",
    "parameters": {
      "model_path": "/path/to/model.json",
      "validation": true
    }
  }
}
```

### 4.4 Stop Message (frontend → kalixcli)
Requests interruption of the currently executing task. Only accepted when kalixcli is in "busy" state.

```json
{
  "type": "stop",
  "timestamp": "2025-09-08T10:33:00Z",
  "session_id": "sess_20250908_103000_a7b9",
  "data": {
    "reason": "User requested cancellation"
  }
}
```

### 4.5 Progress Message (kalixcli → frontend)
Reports progress for the currently executing task. Only sent when in "busy" state.

```json
{
  "type": "progress",
  "timestamp": "2025-09-08T10:32:15Z",
  "session_id": "sess_20250908_103000_a7b9",
  "data": {
    "command": "run_simulation",
    "progress": {
      "percent_complete": 45.2,
      "current_step": "Processing timestep 2023-01-15",
      "estimated_remaining": "00:02:30",
      "details": {
        "timesteps_completed": 452,
        "total_timesteps": 1000,
        "current_phase": "simulation"
      }
    }
  }
}
```

### 4.6 Result Message (kalixcli → frontend)
Reports successful command completion with results.

```json
{
  "type": "result",
  "timestamp": "2025-09-08T10:35:00Z",
  "session_id": "sess_20250908_103000_a7b9",
  "data": {
    "command": "run_simulation",
    "status": "success",
    "execution_time": "00:03:45",
    "result": {
      "summary": {
        "total_timesteps": 1000,
        "simulation_period": "2023-01-01 to 2025-09-08",
        "total_volume": 45632.1
      },
      "data_available": [
        "timeseries_discharge",
        "timeseries_precipitation", 
        "calibration_metrics",
        "water_balance"
      ]
    }
  }
}
```

### 4.7 Stopped Message (kalixcli → frontend)
Reports that a task was successfully interrupted.

```json
{
  "type": "stopped",
  "timestamp": "2025-09-08T10:33:05Z",
  "session_id": "sess_20250908_103000_a7b9",
  "data": {
    "command": "calibrate_model",
    "status": "stopped",
    "execution_time": "00:02:05",
    "partial_result": {
      "iterations_completed": 125,
      "total_iterations": 500,
      "best_parameters_so_far": {
        "parameter_1": 0.75,
        "parameter_2": 1.23
      },
      "note": "Partial results saved and can be resumed"
    }
  }
}
```

### 4.8 Error Message (kalixcli → frontend)
Reports command execution errors.

```json
{
  "type": "error",
  "timestamp": "2025-09-08T10:32:00Z",
  "session_id": "sess_20250908_103000_a7b9",
  "data": {
    "command": "load_model",
    "error": {
      "code": "MODEL_NOT_FOUND",
      "message": "Model file not found at specified path",
      "details": {
        "path": "/invalid/path/model.json",
        "suggestion": "Verify the model file path and permissions"
      }
    }
  }
}
```

### 4.9 Query Message (frontend → kalixcli)
Requests information about current state or available data. Can be sent in both "ready" and "busy" states.

```json
{
  "type": "query",
  "timestamp": "2025-09-08T10:36:00Z",
  "session_id": "sess_20250908_103000_a7b9",
  "data": {
    "query_type": "get_data",
    "parameters": {
      "data_type": "timeseries_discharge",
      "format": "json",
      "start_date": "2023-01-01",
      "end_date": "2023-12-31"
    }
  }
}
```

## 5. Implementation Guidelines

### 5.1 Session Management
- **kalixcli generates unique session IDs** when it starts using timestamp + random component (e.g., `sess_20250908_103000_a7b9`)
- Session ID is first communicated in the initial `ready` message from kalixcli
- Frontend must extract and store the session_id from the initial ready message
- Frontend must use the received session_id in all subsequent messages
- Session ID remains constant for the entire lifetime of the kalixcli process
- Maintain state machine: ready ↔ busy
- Track currently executing command for proper interrupt handling
- Implement graceful shutdown on SIGTERM/SIGINT

### 5.2 Interrupt Handling
- kalixcli must check for incoming messages while executing long-running tasks
- Implement periodic interrupt check points in computational loops
- Ensure clean state after interruption (no partial data corruption)
- Save partial results where appropriate (e.g., calibration iterations)
- Send "stopped" message with partial results when available
- Always return to "ready" state after interruption

### 5.3 Command State Rules
- **In "ready" state**: Accept `command`, `query`, and `terminate` messages
- **In "busy" state**: Accept only `stop`, `query`, and `terminate` messages
- Reject invalid commands based on current state with appropriate error messages
- Queue or reject commands sent during wrong state (implementation choice)

### 5.4 Error Handling
- All errors should include actionable error codes
- Provide human-readable error messages
- Include context and suggestions where possible
- Distinguish between recoverable and fatal errors
- Handle interrupted tasks distinctly from errors

### 5.5 Progress Reporting
- Report progress for operations expected to take >2 seconds
- Include percentage complete and time estimates where feasible
- Provide meaningful step descriptions for user feedback
- Allow progress granularity configuration
- Continue progress updates until task completes or is interrupted

### 5.6 Data Transfer Optimization
- Transfer only requested data subsets to minimize bandwidth
- Support data format options (JSON, CSV, binary)
- Implement data streaming for large datasets
- Cache frequently accessed results
- Preserve data state across interrupted operations

## 6. Standard Command Set

### 6.1 Core Commands
- `load_model`: Load hydrological model from file
- `load_data`: Load input data (precipitation, temperature, etc.)
- `run_simulation`: Execute model simulation (interruptible)
- `calibrate_model`: Perform model calibration (interruptible)
- `validate_model`: Run model validation (interruptible)
- `export_results`: Export results to file

### 6.2 Query Commands
- `get_data`: Retrieve specific datasets
- `get_state`: Get current kalixcli state
- `get_metadata`: Get model/data metadata
- `list_results`: List available result datasets

### 6.3 Utility Commands
- `clear_memory`: Clear loaded data/results
- `set_config`: Configure kalixcli parameters
- `get_version`: Get kalixcli version information

## 7. Frontend Implementation Considerations

### 7.1 Process Management
- Spawn kalixcli with appropriate working directory
- Monitor process health and restart if necessary
- Handle process cleanup on frontend shutdown
- Implement timeout handling for unresponsive commands

### 7.2 Session ID Handling
- Parse the initial `ready` message to extract the session_id
- Store session_id for the lifetime of the kalixcli process
- Include session_id in all messages sent to kalixcli
- Handle session_id mismatch errors if they occur

### 7.3 State Tracking
- Maintain frontend state synchronized with kalixcli state
- Disable/enable UI elements based on ready/busy state
- Show interrupt button only for interruptible busy tasks
- Handle state transition edge cases gracefully

### 7.4 UI Integration
- Parse progress messages for progress bars/indicators
- Display log messages in appropriate UI components
- Handle error messages with user-friendly notifications
- Cache command metadata for command builder interfaces
- Provide clear interrupt/cancel functionality for long-running tasks

### 7.5 Data Management
- Store received data efficiently for frontend use
- Implement data caching strategies
- Handle large dataset transfers gracefully
- Provide data export/visualization capabilities
- Handle partial results from interrupted operations

## 8. Extension Points

### 8.1 Custom Commands
- Plugin architecture for domain-specific commands
- Command registration mechanism
- Parameter validation framework
- Interrupt handler registration for custom commands

### 8.2 Message Types
- Custom message types for specialized use cases
- Message middleware for preprocessing/postprocessing
- Protocol versioning for backward compatibility

### 8.3 Data Formats
- Support for additional data serialization formats
- Compression options for large data transfers
- Binary data transfer protocols for efficiency

## 9. Testing Strategy

- Unit tests for message parsing/generation
- Integration tests for command execution flows
- Session ID handling and validation tests
- Interrupt handling tests for all interruptible commands
- State machine transition testing
- Performance tests for large data transfers
- Error condition testing for robustness
- Frontend-backend integration testing
- Race condition testing for interrupt scenarios