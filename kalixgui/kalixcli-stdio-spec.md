# KalixCLI STDIO Communication Protocol Specification

## 1. Overview

This specification defines a JSON-based communication protocol over STDIO for interaction between a frontend application and the kalixcli hydrological modeling engine. The protocol enables the frontend to initiate modeling tasks, monitor progress, retrieve results, and interrupt long-running operations while keeping computational data resident in kalixcli memory. Models include both configuration and input data as a unified structure.

## 2. Design Principles

### 2.1 Core Principles
- **Stateful Session**: kalixcli maintains model state, data, and results in memory throughout the session
- **Single Task Execution**: kalixcli processes one command at a time, executing tasks sequentially
- **Interruptible Operations**: Long-running tasks can be interrupted by the frontend
- **Concurrent Communication**: kalixcli listens for commands while executing tasks
- **JSON Message Format**: All communication uses structured JSON for clarity and extensibility
- **Line-Delimited**: Each message is a complete JSON object on a single line
- **Extensible**: Protocol structure allows for future command and message type additions
- **Error Resilient**: Clear error reporting and recovery mechanisms

### 2.2 Communication Flow
1. Frontend spawns kalixcli process
2. kalixcli generates a unique session_id and sends ready signal with available commands
3. Frontend receives session_id and uses it for all subsequent messages
4. Frontend sends command
5. kalixcli sends busy signal indicating task has started
6. kalixcli executes command, sending progress updates while listening for interrupts
7. kalixcli sends result or error (or stopped if interrupted)
8. kalixcli sends ready signal for next command
9. Session continues until explicit termination

### 2.3 State Management
kalixcli operates in two primary states:
- **ready**: No task is executing, waiting for commands
- **busy**: A task is executing, can receive interrupt commands while sending progress updates

## 3. Message Structure

### 3.1 Base Message Format
All messages follow this structure:

```json
{
  "type": "message_type",
  "timestamp": "2025-09-08T10:30:00Z",
  "session_id": "unique_session_identifier",
  "data": {}
}
```

**Note**: The `session_id` is generated by kalixcli when it starts and included in all kalixcli → frontend messages for logging/debugging purposes. Frontend messages do not need to include session_id as each kalixcli process handles exactly one session.

### 3.2 Message Types

#### 3.2.1 System Messages (kalixcli → frontend)
- `ready`: kalixcli is ready for commands
- `busy`: kalixcli has started executing a command
- `progress`: Task progress update
- `result`: Task completion with results
- `stopped`: Task was interrupted and stopped cleanly
- `error`: Error occurred during task execution
- `log`: Informational logging message

#### 3.2.2 Command Messages (frontend → kalixcli)
- `command`: Execute a specific kalixcli command
- `stop`: Interrupt the currently executing task
- `query`: Request information about current state
- `terminate`: End the session gracefully

## 4. Detailed Message Specifications

### 4.1 Ready Message (kalixcli → frontend)
Sent when kalixcli starts (with newly generated session_id) and after each command completion/interruption.

```json
{
  "type": "ready",
  "timestamp": "2025-09-08T10:30:00Z",
  "session_id": "sess_20250908_103000_a7b9",
  "data": {
    "status": "ready",
    "available_commands": [
      {
        "name": "load_model_file",
        "description": "Load a hydrological model from a file path",
        "parameters": [
          {"name": "model_path", "type": "string", "required": true}
        ]
      },
      {
        "name": "load_model_string",
        "description": "Load a hydrological model from an INI string",
        "parameters": [
          {"name": "model_ini", "type": "string", "required": true}
        ]
      },
      {
        "name": "run_simulation",
        "description": "Execute model simulation with loaded model and data",
        "parameters": []
      }
    ],
    "current_state": {
      "model_loaded": false,
      "data_loaded": false,
      "last_simulation": null
    }
  }
}
```

### 4.2 Busy Message (kalixcli → frontend)
Sent immediately after kalixcli starts executing a command.

```json
{
  "type": "busy",
  "timestamp": "2025-09-08T10:31:05Z",
  "session_id": "sess_20250908_103000_a7b9",
  "data": {
    "status": "busy",
    "executing_command": "run_simulation",
    "interruptible": true,
    "started_at": "2025-09-08T10:31:05Z"
  }
}
```

### 4.3 Command Message (frontend → kalixcli)
Requests execution of a specific command. Only accepted when kalixcli is in "ready" state.
Frontend messages do not need to include session_id (each kalixcli process handles one session).

```json
{
  "type": "command",
  "timestamp": "2025-09-08T10:31:00Z",
  "data": {
    "command": "load_model_file",
    "parameters": {
      "model_path": "/path/to/model.ini"
    }
  }
}
```

### 4.4 Stop Message (frontend → kalixcli)
Requests interruption of the currently executing task. Only accepted when kalixcli is in "busy" state.

```json
{
  "type": "stop",
  "timestamp": "2025-09-08T10:33:00Z",
  "data": {
    "reason": "User requested cancellation"
  }
}
```

### 4.5 Progress Message (kalixcli → frontend)
Reports progress for the currently executing task. Only sent when in "busy" state.

```json
{
  "type": "progress",
  "timestamp": "2025-09-08T10:32:15Z",
  "session_id": "sess_20250908_103000_a7b9",
  "data": {
    "command": "run_simulation",
    "progress": {
      "percent_complete": 45.2,
      "current_step": "Processing timestep 2023-01-15",
      "estimated_remaining": "00:02:30",
      "details": {
        "timesteps_completed": 452,
        "total_timesteps": 1000,
        "current_phase": "simulation"
      }
    }
  }
}
```

### 4.6 Result Message (kalixcli → frontend)
Reports successful command completion with results.

```json
{
  "type": "result",
  "timestamp": "2025-09-08T10:35:00Z",
  "session_id": "sess_20250908_103000_a7b9",
  "data": {
    "command": "run_simulation",
    "status": "success",
    "execution_time": "00:03:45",
    "result": {
      "summary": {
        "total_timesteps": 1000,
        "simulation_period": "2023-01-01 to 2025-09-08",
        "total_volume": 45632.1
      },
      "data_available": [
        "timeseries_discharge",
        "timeseries_precipitation", 
        "calibration_metrics",
        "water_balance"
      ]
    }
  }
}
```

### 4.7 Stopped Message (kalixcli → frontend)
Reports that a task was successfully interrupted.

```json
{
  "type": "stopped",
  "timestamp": "2025-09-08T10:33:05Z",
  "session_id": "sess_20250908_103000_a7b9",
  "data": {
    "command": "run_simulation",
    "status": "stopped",
    "execution_time": "00:02:05",
    "partial_result": {
      "timesteps_completed": 125,
      "total_timesteps": 500,
      "note": "Simulation interrupted at timestep 125"
    }
  }
}
```

### 4.8 Error Message (kalixcli → frontend)
Reports command execution errors.

```json
{
  "type": "error",
  "timestamp": "2025-09-08T10:32:00Z",
  "session_id": "sess_20250908_103000_a7b9",
  "data": {
    "command": "load_model_file",
    "error": {
      "code": "MODEL_NOT_FOUND",
      "message": "Model file not found at specified path",
      "details": {
        "path": "/invalid/path/model.ini",
        "suggestion": "Verify the model file path and permissions"
      }
    }
  }
}
```

### 4.9 Query Message (frontend → kalixcli)
Requests information about current state or available data. Can be sent in both "ready" and "busy" states.

```json
{
  "type": "query",
  "timestamp": "2025-09-08T10:36:00Z",
  "data": {
    "query_type": "get_state",
    "parameters": {}
  }
}
```

## 5. Implementation Guidelines

### 5.1 Session Management
- **kalixcli generates unique session IDs** when it starts using timestamp + random component (e.g., `sess_20250908_103000_a7b9`)
- Session ID is communicated in all kalixcli → frontend messages for logging/debugging
- Frontend does not need to include session_id in messages (each process = one session)
- Session ID remains constant for the entire lifetime of the kalixcli process
- Maintain state machine: ready ↔ busy
- Track currently executing command for proper interrupt handling
- Implement graceful shutdown on SIGTERM/SIGINT

### 5.2 Interrupt Handling
- kalixcli must check for incoming messages while executing long-running tasks
- Implement periodic interrupt check points in computational loops
- Ensure clean state after interruption (no partial data corruption)
- Save partial results where appropriate (e.g., calibration iterations)
- Send "stopped" message with partial results when available
- Always return to "ready" state after interruption

### 5.3 Command State Rules
- **In "ready" state**: Accept `command`, `query`, and `terminate` messages
- **In "busy" state**: Accept only `stop`, `query`, and `terminate` messages
- Reject invalid commands based on current state with appropriate error messages
- Queue or reject commands sent during wrong state (implementation choice)

### 5.4 Error Handling
- All errors should include actionable error codes
- Provide human-readable error messages
- Include context and suggestions where possible
- Distinguish between recoverable and fatal errors
- Handle interrupted tasks distinctly from errors

### 5.5 Progress Reporting
- Report progress for operations expected to take >2 seconds
- Include percentage complete and time estimates where feasible
- Provide meaningful step descriptions for user feedback
- Allow progress granularity configuration
- Continue progress updates until task completes or is interrupted

### 5.6 Data Transfer Optimization
- Transfer only requested data subsets to minimize bandwidth
- Support data format options (JSON, CSV, binary)
- Implement data streaming for large datasets
- Cache frequently accessed results
- Preserve data state across interrupted operations

## 6. Standard Command Set

### 6.1 Core Commands (Implemented)
- `load_model_file`: Load hydrological model from file path
- `load_model_string`: Load hydrological model from INI string in JSON payload
- `run_simulation`: Execute model simulation (interruptible)
- `test_progress`: Test command demonstrating progress and interruption

### 6.2 Query Commands (Implemented)
- `get_state`: Get current kalixcli state
- `get_version`: Get kalixcli version information

### 6.3 Planned Commands (Not Yet Implemented)
- `calibrate_model`: Perform model calibration (interruptible)
- `validate_model`: Run model validation (interruptible)
- `export_results`: Export results to file
- `get_data`: Retrieve specific datasets
- `clear_memory`: Clear loaded data/results

## 7. Frontend Implementation Considerations

### 7.1 Process Management
- Spawn kalixcli with appropriate working directory
- Monitor process health and restart if necessary
- Handle process cleanup on frontend shutdown
- Implement timeout handling for unresponsive commands

### 7.2 Session ID Handling
- Session ID is provided in kalixcli responses for logging/debugging
- Frontend does not need to track or send session_id
- Each kalixcli process handles exactly one session

### 7.3 State Tracking
- Maintain frontend state synchronized with kalixcli state
- Disable/enable UI elements based on ready/busy state
- Show interrupt button only for interruptible busy tasks
- Handle state transition edge cases gracefully

### 7.4 UI Integration
- Parse progress messages for progress bars/indicators
- Display log messages in appropriate UI components
- Handle error messages with user-friendly notifications
- Cache command metadata for command builder interfaces
- Provide clear interrupt/cancel functionality for long-running tasks

### 7.5 Data Management
- Store received data efficiently for frontend use
- Implement data caching strategies
- Handle large dataset transfers gracefully
- Provide data export/visualization capabilities
- Handle partial results from interrupted operations

## 8. Extension Points

### 8.1 Custom Commands
- Plugin architecture for domain-specific commands
- Command registration mechanism
- Parameter validation framework
- Interrupt handler registration for custom commands

### 8.2 Message Types
- Custom message types for specialized use cases
- Message middleware for preprocessing/postprocessing
- Protocol versioning for backward compatibility

### 8.3 Data Formats
- Support for additional data serialization formats
- Compression options for large data transfers
- Binary data transfer protocols for efficiency

## 9. Testing Strategy

- Unit tests for message parsing/generation
- Integration tests for command execution flows
- Session ID handling and validation tests
- Interrupt handling tests for all interruptible commands
- State machine transition testing
- Performance tests for large data transfers
- Error condition testing for robustness
- Frontend-backend integration testing
- Race condition testing for interrupt scenarios