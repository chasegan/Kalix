[kalix]
start = 2020-01-01
end = 2020-02-01

# This model has two storages with inequal travel times.
# s1 -> 3 days
# s2 -> 2 days
# This setup demonstrates how s2 can make a late release decision 
# based on whether s1 was able to release the previous day.

[inputs]

[node.s1]
loc = 0,0
type = storage
initial_volume = 10000
dimensions = Level [m], Volume [ML], Area [km2], Spill [ML], 
             0.0      , 0.0        , 0.0       , 0.0, 
             10.0     , 10000.0    , 3.0       , 0.0, 
             10.1     , 10001.0    , 3.0       , 1.0E9, 
             500      , 1.0E9      , 3.0       , 1.0E9, 
ds_1 = c1

# This node prevents s1 from releasing every 2nd day
[node.c1]
loc = 0,20
max_order = if(sim.day % 2 == 0, 0, 9999)
type = order_constraint
ds_1 = r1

[node.r1]
loc = 0,40
type = routing
lag = 3
ds_1 = g1

[node.s2]
loc = 40,0
type = storage
initial_volume = 10000
dimensions = Level [m], Volume [ML], Area [km2], Spill [ML], 
             0.0      , 0.0        , 0.0       , 0.0, 
             10.0     , 10000.0    , 3.0       , 0.0, 
             10.1     , 10001.0    , 3.0       , 1.0E9, 
             500      , 1.0E9      , 3.0       , 1.0E9, 
ds_1 = c2

# This node looks at s1 and makes a late decision to order (the 
# day after s1 tries to release) if s1 release was insufficient
[node.c2]
loc = 40,20
type = order_constraint
set_order = max(0, node.c2.ds_1_order[-1,0.0] - node.s1.ds_1[-1,0.0])
ds_1 = r2

[node.r2]
loc = 40,40
type = routing
lag = 2
ds_1 = g1

[node.g1]
loc = 20,60
type = gauge
ds_1 = u1

# A staggered demand to keep it interesting
[node.u1]
loc = 20,80
type = regulated_user
order = 20 + (sim.day % 5)
ds_1 = b1

[node.b1]
loc = 20, 100
type = blackhole

[outputs]
node.s1.ds_1
node.s2.ds_1
node.b1.usflow
node.u1.order
node.u1.order_due
node.u1.demand
node.u1.diversion
node.u1.ds_1